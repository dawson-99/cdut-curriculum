### 寻找质因数

```c++
#include <iostream>
#include <algorithm>

using namespace std;

bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )//不要用开方函数或者i*i小于x。开方函数慢，i*i可能越界
        if (x % i == 0)
            return false;
    return true;
}

int main()
{
    int n;
    cin >> n;

    while (n -- )
    {
        int x;
        cin >> x;
        if (is_prime(x)) cout << "Yes" << endl;
        else cout << "No" << endl;;
    }

    return 0;
}
```

### 分解质因数

```c++
#include <iostream>
#include <algorithm>

using namespace std;

void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )//i <= x / i:防止越界，速度大于 i < sqrt(x)
        if (x % i == 0)//i为底数
        {
            int s = 0;//s为指数
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;//输出
        }
    if (x > 1) cout << x << ' ' << 1 << endl;//如果x还有剩余，单独处理
    cout << endl;
}

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        cin >> x;
        divide(x);
    }

    return 0;
}
```

### AcWing 869. 试除法求约数

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        int n;
        cin >> n;
        vector<int> res;
        //因为约数成对出现，所以只需要循环到根号x
        // 不要是用 i *i <= n，因为可能溢出
        for(int i = 1; i <= n /i; i++)
        {
            if(n % i == 0)
            {
                res.push_back(i);
                //如果i * i = x,添加i即可，不用添加 x / i
                if(n / i != i)
                    res.push_back(n / i);
            }
        }
        sort(res.begin(), res.end());
        for(auto x : res) cout << x << " ";
        cout << endl;

    }
}
```

### AcWing 869. 试除法求约数

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        int n;
        cin >> n;
        vector<int> res;
        //因为约数成对出现，所以只需要循环到根号x
        // 不要是用 i *i <= n，因为可能溢出
        for(int i = 1; i <= n /i; i++)
        {
            if(n % i == 0)
            {
                res.push_back(i);
                //如果i * i = x,添加i即可，不用添加 x / i
                if(n / i != i)
                    res.push_back(n / i);
            }
        }
        sort(res.begin(), res.end());
        for(auto x : res) cout << x << " ";
        cout << endl;

    }
}
```

### 约数个数

```c++
#include <iostream>
#include <algorithm>
#include <unordered_map>
using namespace std;
const int mod = 1e9+7 ;
int main()
{
    
  
 int n; cin>>n;
 unordered_map<int, int> h;
 
 while(n--){
     int k; cin>>k;
     for(int i = 2; i <= k / i; i++){
         if(k % i == 0){
            while(k % i == 0){
                h[i]++;
                k /= i;
            }
         }
     }
     
     if(k > 1) h[k]++;
 }
 
 long long res = 1;
 for(auto m : h) res = res * (m.second + 1) % mod; 
 
 cout<<res;
 
 return 0;   
}
```

### AcWing 871. 约数之和 

![image-20230305124236190](/Users/xuruihang/Library/Application Support/typora-user-images/image-20230305124236190.png)

```c++
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 110, mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;

    unordered_map<int, int> primes;

    while (n -- )
    {
        int x;
        cin >> x;

        for (int i = 2; i <= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x > 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes)
    {
        LL a = p.first, b = p.second;
        LL t = 1;//这里必须是long long
        while (b -- ) t = (t * a + 1) % mod;
        res = res * t % mod;
    }

    cout << res << endl;

    return 0;
}
```

### AcWing 872. 最大公约数

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        int a, b;
        cin >> a >> b;
        //a % b == 0， 则b就是最大公约数，可以提前结束循环。
        while(a % b)
        {
            int c = a % b;
            a = b;
            b = c;
        }
        cout << b << endl;
    }
}
```

### 快速幂

```c++
#include<iostream>
using namespace std;

//a这个参数必然是long long
long long qmi(long long a,int b,int p)
{
    long long res=1;
    while(b)//对b进行二进制化,从低位到高位
    {
        //如果b的二进制表示的第0位为1,则乘上当前的a
        if(b&1) res = res *a %p;
        //b右移一位
        b>>=1;
        //更新a,a依次为a^{2^0},a^{2^1},a^{2^2},....,a^{2^logb}
        a=a*a%p;
    }
    return res;
}
int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int a,b,p;
        long long res=1;
        cin>>a>>b>>p;
        res = qmi(a,b,p);
        cout<<res<<endl;
    }
    return 0;
}
```

### 拓展欧几里得

```c++
#include<bits/stdc++.h>
using namespace std;

void exgcd(int a, int b, int & x, int & y){
    
    if(b == 0){
        x = 1; y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    int x1 = x, y1 = y;
    x = y1, y = x1 - a / b * y1;
}


int main(){
    
    int n;cin>>n;
    
    while(n--){
        
        int a, b, x, y; cin>>a>>b;
        exgcd(a, b, x, y);
        cout<<x<<" "<<y<<endl;
    }
    return 0;
}
```

### 求组合数

```c++
#include<iostream>
using namespace std;
const int mod = 1e9+7;
long long f[2010][2010];
int main()
{
    //预处理
    for(int i=0;i<=2000;i++)
    {
        for(int j=0;j<=i;j++)
        {
            if(!j) f[i][j]=1;
            else f[i][j]=(f[i-1][j-1]+f[i-1][j])%mod;
        }
    }
    int n;
    cin>>n;
    while(n--)
    {
        int a,b;
        cin>>a>>b;
        printf("%ld\n",f[a][b]);
    }
}
```

### 快速求逆元

```c++
#include <iostream>
using namespace std;
typedef long long LL;

LL qmi(LL a, int m, int p){
    
    LL res = 1;
    while(m){
        
        if(m & 1) res = res * a % p;
        a = (a * a) % p;
        m >>= 1;
        
    }
    return res;
}


int main(){
    
    
    int n; cin>>n;
    
    while(n--){
        
        int a, p; cin>>a>>p;
        if( a % p == 0) puts("impossible");
        else cout<<qmi(a, p - 2, p)<<endl;
    }
    return 0;
}
```

### 求组合数 1e5

```c++
#include<iostream>
#include<algorithm>

using namespace std;

typedef long long LL;
const int N=100010,mod=1e9+7;

LL fact[N],infact[N];//fact表示阶乘,infact表示阶乘的逆元

int qmi(int a,int k,int p)
{
    int res=1;
    while(k)
    {
        if(k&1) res=(LL)res*a%p;
        a=(LL)a*a%p;
        k>>=1;
    }
    return res;
}

int main(){
    
    fact[0] = 1;
    infact[0] = 1;
    for(int i = 1; i <= 1e5; i++){
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }
    
    int n; cin>>n;
    while(n--){
        int a, b; cin>>a>>b;
        cout<<fact[a] * infact[b] % mod * infact[a - b] % mod<<endl;
    }
    
    return 0;
}
```



### 求组合数

```c++
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

const int N=5010;

int primes[N],cnt;
int sum[N];
bool st[N];

void get_primes(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])primes[cnt++]=i;
        for(int j=0;primes[j]*i<=n;j++)
        {
            st[primes[j]*i]=true;
            if(i%primes[j]==0)break;//==0每次漏
        }
    }
}
// 对p的各个<=a的次数算整除下取整倍数
int get(int n,int p)
{
    int res =0;
    while(n)
    {
        res+=n/p;
        n/=p;
    }
    return res;
}
//高精度乘
vector<int> mul(vector<int> a, int b)
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    // while(C.size()>1 && C.back()==0) C.pop_back();//考虑b==0时才有pop多余的0 b!=0不需要这行
    return c;
}

int main()
{
    int a,b;
    cin >> a >> b;
    get_primes(a);

    for(int i=0;i<cnt;i++)
    {
        int p = primes[i];
        sum[i] = get(a,p)-get(a-b,p)-get(b,p);//是a-b不是b-a
    }

    vector<int> res;
    res.push_back(1);

    for (int i = 0; i < cnt; i ++ )
        for (int j = 0; j < sum[i]; j ++ )//primes[i]的次数
            res = mul(res, primes[i]);

    for (int i = res.size() - 1; i >= 0; i -- ) printf("%d", res[i]);
    puts("");

    return 0;
}
```

### 能被整除的数

```c++
#include<iostream>
using namespace std;
typedef long long LL;

const int N = 20;
int p[N], n, m;

int main() {
    cin >> n >> m;
    for(int i = 0; i < m; i++) cin >> p[i];

    int res = 0;
    //枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合)
    for(int i = 1; i < 1 << m; i++) {
        int t = 1;             //选中集合对应质数的乘积
        int s = 0;             //选中的集合数量

        //枚举当前状态的每一位
        for(int j = 0; j < m; j++){
            //选中一个集合
            if(i >> j & 1){
                //乘积大于n, 则n/t = 0, 跳出这轮循环,这一步的判断必须要有，目前猜测的原因是，如果不判断，t的范围会超越，会出现一些小于n的数字，导致错误
                if((LL)t * p[j] > n){    
                    t = -1;
                    break;
                }
                s++;                  //有一个1，集合数量+1
                t *= p[j];
            }
        }

        if(t == -1) continue;  

        if(s & 1) res += n / t;              //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量
        else res -= n / t;                      //反之则为 -1
    }

    cout << res << endl;
    return 0;
}
```



### 滑雪

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 310;
int n,m; //网格滑雪场的行和列
int f[N][N]; //状态转移式
int h[N][N]; //网格滑雪场
int dx[4] = {-1,0,1,0};
int dy[4] = {0,1,0,-1};
int vist[N][N];

int dp(int x, int y){
    
    if(vist[x][y] == 1){
        return f[x][y];
    }
    
    vist[x][y] = 1;
    f[x][y] = 1;

    for(int i = 0; i < 4; i++){
        int a = x + dx[i], b = y + dy[i];
        if(a >= 1 && a <= n && b >= 1 && b <= m && h[x][y] > h[a][b]){
             f[x][y] = max(f[x][y], dp(a, b) + 1);
        }
    }
    
    return f[x][y];


}


int main(){
    
    cin>>n>>m;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            cin>>h[i][j];
        }
    }
    
    memset(f, -1, sizeof f);
    
    int res = 0;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            res = max(res, dp(i, j));
        }
    }
    
    cout<<res;
    return 0;
    
}
```

### \92. 递归实现指数型枚举

```c++
#include<iostream>
using namespace std;

int n;
int path[15], state[15];


int main(){
    cin>>n;
    
    for(int i = 0; i < 1 << n; i++){
        for(int j = 0; j <= n; j++){
            if(i >> j & 1) cout<< j + 1<<" ";
        }
        cout<<endl;
    }
    
    return 0;
}
```

### 递归实现指数型枚举

```c++
#include <iostream>
using namespace std;

int n;
int a[20];
bool vis[20];

// 当前枚举到第pos个坑， 上一个坑填的是start-1，这次只能从start开始找数填， 一共要填tar个坑
void dfs(int pos, int start, int tar) {
    if (pos == tar + 1) {
        for (int i = 1; i <= tar; i ++ ) cout << a[i] << " ";
        cout << endl;
        return ;
    }

    // 选数填坑，选择的数范围是start～n
    for (int i = start; i <= n; i ++) {
        if (!vis[i]) {
            vis[i] = true; a[pos] = i;
                dfs (pos + 1, i + 1, tar);
            vis[i] = false;
        }
    }
}

int main() {
    cout << endl;
    cin >> n;
    for (int i = 1; i <= n; i ++ )
        dfs(1, 1, i);
    return 0;
}
```

### 递归实现指数型枚举

```c++
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    // state 是每一个状态
    for (int state = 0; state < 1 << n; state ++ ) {
        // 用指针j遍历二进制数state中的每一位
        for (int j = 0; j < n; j ++ ) {
            if (state >> j & 1) cout << j + 1 << " ";
        }
        cout << endl;
    }
    return 0;
}
```

### 递归实现指数型枚举

```c++
#include <iostream>
using namespace std;

int n;

// u是当前枚举到的数，state是二进制数记录哪些数被选
void dfs(int u, int state) {
    if (u == n) {
        for (int i = 0; i < n; i ++)
            if (state >> i & 1)
                cout << i + 1 << " ";
            cout << endl;
        return ;
    }

    dfs (u + 1, state);  // 不用u这个数
    dfs (u + 1, state | (1 << u)); // 用u这个数
}

int main() {
    cin >> n;
    dfs(0, 0);
    return 0;
}
```

### AcWing 94. 递归实现排列型枚举

```c++
#include<iostream>
using namespace std;
const int N = 10;
int path[N];//保存序列
int state[N];//数字是否被用过
int n;
void dfs(int u)
{
    if(u > n)//数字填完了，输出
    {
        for(int i = 1; i <= n; i++)//输出方案
            cout << path[i] << " ";
        cout << endl;
    }

    for(int i = 1; i <= n; i++)//空位上可以选择的数字为:1 ~ n
    {
        if(!state[i])//如果数字 i 没有被用过
        {
            path[u] = i;//放入空位
            state[i] = 1;//数字被用，修改状态
            dfs(u + 1);//填下一个位
            state[i] = 0;//回溯，取出 i
        }
    }
}

int main()
{

    cin >> n;
    dfs(1);
    return 0;
}
```

### \717. 简单斐波那契

```c++
#include<iostream>
using namespace std;
const int N = 50;

int n;
int dp[N];


int main(){
    
    cin>>n;
    dp[1] = 0; dp[2] = 1;
    
    for(int i = 3; i <= n; i++){
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    for(int i = 1; i <= n; i++){
        cout<<dp[i]<<" ";
    }
    

    return 0;
}
```

### 95. 费解的开关

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

const int N = 6;
int dx[N] = {-1, 0, 1, 0, 0}, dy[N] = {0, 1, 0, -1, 0};
char g[N][N], backup[N][N];


// 这个操作是把(x, y)以及上下左右的灯都变成相反的颜色
void turn (int x, int y)
{
    for (int i = 0; i < 5; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];

        //如果在边界外边，直接忽略即可
        if (a < 0 || a >= 5 || b < 0 || b >= 5) continue;

        g[a][b] ^= 1;   //异或，不同的时候就变成相反的数
    }

}


int main()
{
    int n;
    scanf("%d", &n);
    while(n -- )
    {
        // 按行输入，把每一行当成一个字符串
        for (int i = 0; i < 5; i ++ ) cin >> g[i];

        int res = 10;

        // 这里我们枚举了第一行的32种按法，不用管是亮是灭，把第一行所有情况都按一遍
        // 按每种情况的第一行，去遍历接下来的行
        // 枚举32种第一行的按法只是可能会减少步数，如果直接从第二行开始答案一定是固定的了，找不到最优解或者可能没有解

        for (int op = 0; op < 32; op ++ )
        {
            // 我在对这种情况操作的时候，得先备用一下
            // 把原始数组备份一下，然后操作g，操作完了还原，然后再操作
            memcpy(backup, g, sizeof g);

            int step = 0;

            // 第一行的按法(在这里 1 表示按了, 0 表示不按)，这里只是为了输出第一行按完之后的状态
            for (int i = 0; i < 5; i ++ )
                if (op >> i & 1)  // 数字2 对应了 00010 表示第2个位置的按一下
                                  // 00010 >> 1 & 1  是1 所以turn(0, 1) 就是第一行第二个位置
                {                 // 数字3 对应了00011 表示第1 和第2个位置的按一下
                    step ++ ;
                    turn (0, i);;
                }

            // 然后通过第一行按完之后的状态，按234行
            for (int i =0; i < 4; i ++ )
                for (int j = 0; j < 5;j ++ )
                    if (g[i][j] == '0')
                    {
                        step ++;
                        turn (i + 1, j);  // 如果这个位置是灭的，就按下一行对应的位置
                    }

            bool dark = false;
            for (int j = 0; j < 5; j ++ )
                if (g[4][j] == '0')
                {
                    dark = true;
                    break;
                }


            // 对于32种情况的这一种，如果所有的全亮就记录下步数(事实上只记录了最后一行是否dark)
            if (!dark) res = min(res, step);
            memcpy (g, backup, sizeof g);
        }

        if(res > 6) res = -1;
        cout << res << endl;

    }
    return 0;
}
```

### 带分数

```c++
#include <iostream>

using namespace std;

const int N = 10;

int target;  // 题目给出的目标数
int num[N];  // 保存全排列的结果
bool used[N];  // 生成全排列过程中标记是否使用过
int cnt;  // 计数，最后输出的结果

// 计算num数组中一段的数是多少
int calc(int l, int r) {
  int res = 0;
  for (int i = l; i <= r; i++) {
    res = res * 10 + num[i];
  }
  return res;
}

// 生成全排列
// 当全排列生成后进行分段
void dfs(int u) {
  // 用两层循环分成三段
  if (u == 9) {
    for (int i = 0; i < 7; i++) {
      for (int j = i + 1; j < 8; j++) {
        int a = calc(0, i);
        int b = calc(i + 1, j);
        int c = calc(j + 1, 8);
        // 注意判断条件，因为C++中除法是整除，所以要转化为加减乘来计算
        if (a * c + b == c * target) {
          cnt++;
        }
      }
    }
    return;
  }
  // 搜索模板
  for (int i = 1; i <= 9; i++) {
    if (!used[i]) {
      used[i] = true; // 标记使用
      num[u] = i;
      dfs(u + 1);
      used[i] = false; // 还原现场
    }
  }
}

int main() {
  scanf("%d", &target);
  dfs(0);
  printf("%d\n", cnt);
  return 0;
}
```

### 带分数

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 10;

int target;
int num[N];

int calc(int l, int r) {
  int res = 0;
  for (int i = l; i <= r; i++) {
    res = res * 10 + num[i];
  }
  return res;
}

int main() {
  cin >> target;
  for (int i = 0; i < 9; i++) {
    num[i] = i + 1;
  }
  int res = 0;
  do {
    for (int i = 0; i < 9; i++) {
      for (int j = i + 1; j < 9; j++) {
        int a = calc(0, i);
        int b = calc(i + 1, j);
        int c = calc(j + 1, 8);
        if (a == 0 || b == 0 || c == 0) {
          continue;
        }
        if (a * c + b == c * target) {
          ++res;
        }
      }
    }
    // 调用函数生成全排列
  } while (next_permutation(num, num + 9));
  cout << res << '\n';
  return 0;
}
```

### 飞行员兄弟

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<algorithm>

//这个宏定义其实也就最后输出的时候应用了（如果我没猜错的话），但是y总的习惯就是好习惯！
#define x first
#define y second

using namespace std;

typedef pair<int,int> PII;

const int N=5;

char g[N][N],backup[N][N];


//映射函数
int get(int x,int y)
{
    return x*4+y;//返回第x行第y列上的数是多少
}

void turn_one(int x,int y)
{
    if(g[x][y]=='+') g[x][y]='-';
    else g[x][y]='+';
}

void turn_all(int x,int y)
{
    for(int i=0;i<4;i++)
    {
        turn_one(x,i);
        turn_one(i,y);
    }
    turn_one(x,y);

}

int main()
{
    for(int i=0;i<4;i++)
        for(int j=0;j<4;j++)
            cin>>g[i][j];

    vector<PII> res;//这是记录方案所需要的结构

    //枚举所有的方案
    for(int op=0;op<1<<16;op++)
    {
        vector<PII> temp;//temp里面存的是方案
        //先备份一下，为什么？因为这又不是最终方案，我们要把所有方案都试一遍，求最少的
        memcpy(backup,g,sizeof g);

        //枚举16个位置,进行操作
        for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)
                if(op>>get(i,j)&1) //如果当前位置是1的话--get的作用就是返回二进制数中那一位是第几位，从而判断是否为1
                {
                    temp.push_back({i,j});
                    //按一下开关
                    turn_all(i,j);
                }


        //判断所有灯泡是否全亮
        bool has_closed=false;
        for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)
                if(g[i][j]=='+') has_closed=true;

        if(has_closed==false)
        {
            //如果方案为空或者他的操作数大于我们刚存好的新的方案，那么就修改它
            if(res.empty()||res.size()>temp.size()) res=temp;
        }
        //还原回来，供下一个方案操作
        memcpy(g,backup,sizeof g);
    }
    //因为没说无解，所以可以猜想一下一定有解
    cout<<res.size()<<endl;
    //这里的迭代函数就是一种简便写法，不要误解
    //另外原题下标从1开始，所以下面加1了
    for(auto op:res) cout<<op.x+1<<" "<<op.y+1<<endl;

    return 0;
}
```

### 翻硬币

```c++
//cpp
#include <iostream>
#include <string>
using namespace std;
const int N = 110;//用不到，看范围就直接写了

int main()
{
    string s1, s2;//s1:初始状态，s2:目标状态
    int cnt = 0;//记录翻转次数
    cin >> s1 >> s2;
    for (int i = 0; i < s1.size() - 1; i++)
    {
        if (s1[i] != s2[i])//第 i 个位置上状态不同，就翻转该位置和后一个位置硬币
        {
            cnt++;//翻转一次硬币
            if (s1[i] == '*') s1[i] = 'o';//翻转 i 位置上的硬币
            else s1[i] = '*';
            if (s1[i+1] == 'o') s1[i+1] = '*';//翻转 i + 1 位置上的硬币
            else s1[i+1] = 'o';
        }
    }
    cout << cnt;//输出翻转次数
}
```

### 二分模板

```c++
int L=-1,R=n;
while(L+1!=R)
{
	int mid=L+R>>1;
	if(check()) L=mid;
	else R=mid;
	//最后根据你所分左右两边区间的结果
	//选取L或者R作为结果
}

```

![image-20230314162912396](/Users/xuruihang/Library/Application Support/typora-user-images/image-20230314162912396.png)

### 数的范围

```c++
#include<iostream>
using namespace std;
const int N=1e5+5;
int n, m, q[N];
int main()
{
    
    cin>>n>>m;
    
    for(int i = 0; i < n; i++) cin>>q[i];
    
    while(m--){
        
        int k; cin>>k;
        int l = -1, r = n;
        
        while(l + 1 != r){
            int mid = l + r >> 1;
            if(q[mid] >= k) r = mid;//右半部分大于k
            else l = mid;
        }
        
        if(q[r] != k) cout<<"-1 -1"<<endl;
        else{
            cout<<r<<" ";
            
            int l = -1, r = n;
        
            while(l + 1 != r){
                int mid = l + r >> 1;
                if(q[mid] <= k) l = mid;//左半部分小于k
                else r = mid;
            }
            
            cout<<l<<endl;
            
        }
    }
    return 0;   
}
```

### 四次方，拉格朗日

```c++
//四平方和
//模拟哈希表
#include<bits/stdc++.h>

using namespace std;

typedef pair<int,int> PII;

const int N = 5e6 + 10;

int n;
int r[N * 2];//小技巧，避免pair，r[c^2+d^2]=c;可以推导出d

int main()
{
    cin >> n;

    memset(r, -1, sizeof r);

    for(int c = 0; c * c <= n; c++)
    {
        for(int d = c; c * c + d * d <= n; d++)
        {
            int t = c * c + d * d;
            if(r[t] == -1)
            {
                r[t] = c;
            }
        }
    }

    for(int a = 0; a * a <= n; a ++)
    {
        for(int b = a; a * a + b * b <= n; b++)
        {
            int t = n - a * a - b * b;
            int c = r[t];
            if(r[t] == -1) continue;
            int d = sqrt(t - c * c);
            printf("%d %d %d %d\n", a, b, c, d);
            return 0;
        }
    }
    return 0;
}
```

### 730. 机器人跳跃问题

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int num[N];
int n;
int main(){
    cin>>n;
    for(int i=0;i<n;i++)cin>>num[i];
    int res = 0;
        for(int i = n - 1; i >= 0; i--){
            if((num[i] + res) % 2 == 0)
                res = (num[i] + res) / 2;
            else
                res = (num[i] + res) / 2 + 1;
        }
    cout<<res<<endl;
}
```

```c++
#include<iostream>using namespace std;const int N = 1e5 + 10;int n;int q[N];bool check(int e){    for(int i = 0; i < n; i++){        e = 2 * e - q[i];        if(e > 1e5) return true;        if(e < 0){            return false;        } //升序队列
priority_queue <int,vector<int>,greater<int> > q;
//降序队列
priority_queue <int,vector<int>,less<int> >q;            }    return true;    }int main(){    cin>>n;    for(int i = 0; i < n; i++) scanf("%d", &q[i]);        int l = -1, r = 1e5;    while(l + 1 != r){                int mid = (l + r) >> 1;        if(check(mid)) r = mid;        else l = mid;            }        cout<<r;    return 0;}
```

### 分巧克力

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, k;  // 有n块巧克力，k个小朋友
int wid[N], len[N];  // 分别保存巧克力的长和宽

// 计算当正方形的边长为u时，总共能分得多少块巧克力
int get_sum(int u) {
  int sum = 0;
  for (int i = 0; i < n; i++) {
    // 要的就是整除
    sum += ((wid[i] / u) * (len[i] / u));
  }
  return sum;
}

int main() {
  scanf("%d%d", &n, &k);
  for (int i = 0; i < n; i++) {
    scanf("%d%d", &wid[i], &len[i]);
  }
  // 二分模板
  // 按照y总所分析的，我这里所取的性质是“当边长取mid时，能够分得k块巧克力”
  // 显然在一个数轴上，目标值的左侧（比目标值小的数）都是满足这个性质的，右边则不满足
  // 所以我们要找的值是满足这个性质的最右端
  // 如果当前取的mid满足这个性质，那么l有可能就是我们要找的目标值，所以用l = mid来更新
  // 综上所述，用以下模板
  int l = 0, r = N;
  while (l < r) {
    int mid = (l + r + 1) >> 1;
    if (get_sum(mid) >= k) {
      l = mid;
    } else {
      r = mid - 1;
    }
  }
  printf("%d\n", l);
  return 0;
}
```

### 炸弹

```c++
#include <iostream>

using namespace std;

#define N 5002
int f[N][N];

int main() {

    int n, r;
    int max_x, max_y;
    int x = 0, y = 0, w = 0;
    cin >> n >> r;
    r = min(r, 5001); // 爆炸范围超过5001时覆盖了所有目标范围，因此没必要考虑超出范围。
    max_x = max_y = r;// 最小的爆炸计算范围是在一个最小爆炸范围之内计算
    for (int i = 0; i < n; ++i) {
        cin >> x >> y >> w;
        f[++x][++y] += w; // 将目标范围统一偏移1，便于边界计算。
        max_x = max(x, max_x); // 如果有目标落在一个最小爆炸范围之外，则扩大计算范围。
        max_y = max(y, max_y);
    }
    // 下面两个循环的计算公式都需要自己用手画一下，才能获得利用二维前缀和计算总价值的结果
    for (int i = 1; i <= max_x; ++i) { // 循环从偏移的1开始
        for (int j = 1; j <= max_y; ++j) {
            f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + f[i][j];
        }
    }

    int ans = 0;
    for (int i = r; i <= max_x; ++i) {
        for (int j = r; j <= max_y; ++j) {
            ans = max(ans, f[i][j] - f[i - r][j] - f[i][j - r] + f[i - r][j - r]);
        }
    }

    cout << ans << endl;

    return 0;
} 
```

### 最大不能凑成的数

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int n, m, minn, maxx, ans;
bool dp[1000000];
int main() {
    cin >> n >> m;
    dp[0] = true;
    minn = min(n, m);
    maxx = max(n, m);
    for (int i = minn; i < n * m; i++) {
        if (dp[i - minn]) {
            dp[i] = true;
        } else if (i >= maxx && dp[i - maxx]) {
            dp[i] = true;
        } else {
            ans = i;
        }
    }
    
    if(n == 2 && m == 3) cout<<1<<endl;
    else cout << ans;
    return 0;
}
```

```c++
#include <iostream>

using namespace std;

//给定一个m，是否能用p和q凑出来
bool dfs(int m,int p,int q)
{
    if(m == 0) return true;

    if(m >= p && dfs(m - p,p,q)) return true;
    if(m >= q && dfs(m - q,p,q)) return true;

    return false;
}

int main()
{
    int p,q;
    cin >> p >> q;
    int res = 0;
    for(int i = 1; i <= 1000;i ++)
    {
        if(!dfs(i,p,q)) res = i;
    }

    cout << res << endl;

    return 0;
}
```

### 最长上升子序列

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int w[N], f[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> w[i];

    int mx = 1;    // 找出所计算的f[i]之中的最大值，边算边找
    for (int i = 0; i < n; i++) {
        f[i] = 1;    // 设f[i]默认为1，找不到前面数字小于自己的时候就为1
        for (int j = 0; j < i; j++) {
            if (w[i] > w[j]) f[i] = max(f[i], f[j] + 1);    // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1
        }
        mx = max(mx, f[i]);
    }

    cout << mx << endl;
    return 0;
}
```

### 地宫探宝

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 55;
const int M = 15;
const int MOD = 1e9 + 7;

int n, m, c;
int a[N][N];
// f[i][j][cnt][k] 表示：在 (i, j) 这个点，拿了 cnt 个物品，这些物品中价值最大的是 k
int f[N][N][M][M];

int main() {
  scanf("%d%d%d", &n, &m, &c);
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      scanf("%d", &a[i][j]);
      a[i][j]++;
    }
  }
  // 两个边界初始化
  // 在起点 (1, 1) 处
  // 如果拿也只能拿 a[i][j] 这个物品，只有一种方案
  // 如果不拿，那就是 0 个物品，也是一个方案数
  // 由于物品价值已经增加了一个偏移量，现在价值的范围是 [1, 13]
  // 所以价值为 0 并不代表物品的价值，而是一个边界点
  f[1][1][0][0] = 1;
  f[1][1][1][a[1][1]] = 1;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      for (int cnt = 0; cnt <= c; cnt++) {
        for (int k = 0; k < M; k++) {
          // 不拿物品
          f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i - 1][j][cnt][k]) % MOD;
          f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i][j - 1][cnt][k]) % MOD;
          // 可以拿
          if (cnt > 0 && k == a[i][j]) {
            for (int s = 0; s < a[i][j]; s++) {
              f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i - 1][j][cnt - 1][s]) % MOD;
              f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i][j - 1][cnt - 1][s]) % MOD;
            }
          }
        }
      }
    }
  }
  // 最后把在终点 (n, m) 处拿 c 个物品的方案数累加
  int res = 0;
  for (int i = 1; i < M; i++) {
    res = (res + f[n][m][c][i]) % MOD;
  }
  printf("%d\n", res);
  return 0;
}
```

### 递增3元组

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;
const int N = 1e5+10;
int a[N], b[N], c[N];


int main(){
    
    int n;
    cin>>n;
    
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    sort(a + 1, a + 1 + n);
    for(int i = 1; i <= n; i++) scanf("%d", &b[i]);
    sort(b + 1, b + 1 + n);
    for(int i = 1; i <= n; i++) scanf("%d", &c[i]);
    sort(c + 1, c + 1 + n);
    
    LL ans = 0;
    
    for(int i = 1; i <= n; i++){
        
        int key = b[i];
        
        //在a中找到恰好小于key的数的坐标
        int pos1 = lower_bound(a + 1, a + n + 1, key) - a - 1; //因为查找到的是等于key的，所以要减1
        //在c中找到恰好大于key的数的坐标
        int pos2 = upper_bound(c + 1, c + n + 1, key) - c;
        
        ans += (LL)(n - pos2 + 1) * (pos1);
        
    }
    
    cout<<ans;
    return 0;
}
```

```c++
//前缀和
#include <iostream>
#include <cstdio>

using namespace std;

typedef long long LL;
const int N = 1e5+10;
int A[N], B[N], C[N];
int cnta[N], cntc[N], sa[N], sc[N];

int main() {
    int n;
    scanf("%d", &n);
    //获取数i在A中有cntc[i]个，并对cnt求前缀和sa
    for(int i = 1; i <= n; ++i) {
        scanf("%d", &A[i]);
        cnta[++A[i]]++;
    }
    sa[0] = cnta[0];
    for(int i = 1; i < N; ++i) sa[i] = sa[i-1]+cnta[i];
    //B只读取即可
    for(int i = 1; i <= n; ++i) scanf("%d", &B[i]), B[i]++;

    //获取数i在C中有cntc[i]个，并对cnt求前缀和sc
    for(int i = 1; i <= n; ++i) {
        scanf("%d", &C[i]);
        cntc[++C[i]]++;
    }
    sc[0] = cntc[0];
    for(int i = 1; i < N; ++i) sc[i] = sc[i-1]+cntc[i]; 

    //遍历B求解
    LL ans = 0;
    for(int i = 1; i <= n; ++i) {
        int b = B[i];
        ans += (LL)sa[b-1] * (sc[N-1] - sc[b]);
    }
    cout<<ans<<endl;
    return 0;
}
```

### 线段🌲

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N=100010;

int n,m;

int w[N];//记录一下权重

struct node{
    int l,r;//左右区间

    int sum;//总和
}tr[N*4];//记得开 4 倍空间

void push_up(int u)//利用它的两个儿子来算一下它的当前节点信息
{
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;//左儿子 u<<1 ,右儿子 u<<1|1  
}

void build(int u,int l,int r)/*第一个参数，当前节点编号，第二个参数，左边界，第三个参数，右边界*/
{
    if(l==r)tr[u]={l,r,w[r]};//如果当前已经是叶节点了，那我们就直接赋值就可以了
    else//否则的话，说明当前区间长度至少是 2 对吧，那么我们需要把当前区间分为左右两个区间，那先要找边界点
    {
        tr[u]={l,r};//这里记得赋值一下左右边界的初值

        int mid=l+r>>1;//边界的话直接去计算一下 l + r 的下取整

        build(u<<1,l,mid);//先递归一下左儿子

        build(u<<1|1,mid+1,r);//然后递归一下右儿子

        push_up(u);//做完两个儿子之后的话呢 push_up 一遍u 啊，更新一下当前节点信息
    }
}

int query(int u,int l,int r)//查询的过程是从根结点开始往下找对应的一个区间
{
    if(l<=tr[u].l&&tr[u].r<=r)return tr[u].sum;//如果当前区间已经完全被包含了，那么我们直接返回它的值就可以了
    //否则的话我们需要去递归来算
    int mid=tr[u].l+tr[u].r>>1;//计算一下我们 当前 区间的中点是多少
    //先判断一下和左边有没有交集

    int sum=0;//用 sum 来表示一下我们的总和

    if(mid>=l)sum+=query(u<<1,l,r);//看一下我们当前区间的中点和左边有没有交集
    if(r>=mid+1)//看一下我们当前区间的中点和右边有没有交集
    sum+=query(u<<1|1,l,r);

    return sum;

}

void modify(int u,int x,int v)//第一个参数也就是当前节点的编号,第二个参数是要修改的位置，第三个参数是要修改的值
{
    if(tr[u].l==tr[u].r)tr[u].sum+=v; //如果当前已经是叶节点了，那我们就直接让他的总和加上 v 就可以了

    //否则
    else
    {

      int mid=tr[u].l+tr[u].r>>1;
      //看一下 x 是在左半边还是在右半边
      if(x<=mid)modify(u<<1,x,v);//如果是在左半边，那就找左儿子
      else modify(u<<1|1,x,v);//如果在右半边，那就找右儿子

      //更新完之后当前节点的信息就要发生变化对吧，那么我们就需要 pushup 一遍

      push_up(u);
    }

}

int main()
{
    scanf("%d%d",&n,&m);

    for(int i=1;i<=n;i++)scanf("%d",&w[i]);

    build(1,1,n);/*第一个参数是根节点的下标，根节点是一号点，然后初始区间是 1 到 n */

    //后面的话就是一些修改操作了

    while(m--)
    {
        int k,a,b;

        scanf("%d%d%d",&k,&a,&b);

        if(!k)printf("%d\n",query(1,a,b));//求和的时候，也是传三个参数，第一个的话是根节点的编号 ，第二个的话是我们查询的区间 
        //第一个参数也就是当前节点的编号
        else
        modify(1,a,b);//第一个参数是根节点的下标,第二个参数是要修改的位置，第三个参数是要修改的值

    }
    return 0;
}
```

### 数星星

```c++
#include<iostream>
using namespace std;
const int N = 32000 + 10;

int w[N];
int s[N];
int level[N];

int lowbit(int x){
    return x & -x;
}

void add(int x){
    
    for(int i = x; i < N; i = i + lowbit(i)){
        s[i] ++;
    }
    
}

int sum(int x){
    
    int res = 0;
    while(x){
        res += s[x];
        x = x - lowbit(x);
    }
    return res;
}

int main(){
    
    int n; cin>>n;
    for(int i = 0; i < n; i++){
        
        int x, y;
        scanf("%d%d", &x, &y);
        x++;
        level[sum(x)]++;
        add(x);
        
    }
    
    for(int i = 0; i < n; i++){
        cout<<level[i]<<endl;
    }
    
    return 0;
}
```

### 日志统计

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

#define x first
#define y second

const int N = 100010;

int n, d, k;
PII logs[N];
bool st[N];//用来标记id号，因为id <= 1e5，所以可以利用遍历来输出。
int cnt[N];//用来记录一个id号获得的赞数，表示形式为cnt[id]++;

int main(){
    scanf("%d%d%d", &n, &d, &k);

    for (int i = 0; i < n; i ++ ) scanf("%d%d", &logs[i].x, &logs[i].y);
    //排序时默认以first为准排序
    sort(logs, logs + n);

    //双指针算法， i走在前面，j走在后面
    for (int i = 0, j = 0; i < n; i ++ ){
        int t = logs[i].y;//t表示为i时刻的id号
        cnt[t] ++;//在j时刻，id号为t的大佬日记获得了一个赞，给t大佬加一分

        while (logs[i].x - logs[j].x >= d){//两个指针跨越的时间超过了d，早期的赞过期了
            cnt[logs[j].y] --;//就是这位大佬，获赞的时间太久远了，赞作废了，哭去吧
            j ++;//在logs[j].x时刻的太久远了，往前挪挪。
            //这个循环，直到最后一个赞不过期为止。
        }
        //记录热帖的id号，好知道谁才是大佬
        if (cnt[t] >= k) st[t] = true;
    }

    //遍历一遍id号，展现大佬
    for (int i = 0; i <= 100000; i ++ ) if (st[i]) cout << i << endl;

    return 0;
}
```

### 寻找花束

```c++
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
typedef pair<int, int> PII;

const int N = 210;

char a[N][N];
int dis[N][N];

void bfs(PII start)
{
    queue<PII> q;
    q.push(start);//队头队，对应步骤1
    while(!q.empty())
    {
        PII u = q.front();
        q.pop();
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0 ,-1};
        for(int i = 0; i < 4; i++)//遍历四个方向，对应步骤2
        {
            int x = u.first + dx[i];
            int y = u.second + dy[i];

            if(a[x][y] == '#') continue;//如果是'#',不做任何处理
            if(a[x][y] == '.')//如果是 '.'，更新对应内容
            {
                dis[x][y] = dis[u.first][u.second] + 1;
                a[x][y] = '#';
                q.push({x, y});
            }
            if(a[x][y] == 'E')//如果是'E'，找到了，输出
            {
                cout << dis[u.first][u.second] + 1 << endl;
                return;
            }
        }
    }
    cout << "oop!" << endl;//没有找到

}

int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        memset(a, '#', sizeof(a));//初始化地图，各个点都是墙。
        memset(dis, 0, sizeof(dis));//初始化dis
        int n,m;
        PII start;
        cin >> n >> m;
        for(int i = 1; i <= n; i++)//从第一行存储地图，因为四周都是墙，bfs时，可以不做越界判断
        {
            for(int j = 1; j <= m; j++)//从第一；列存储地图，因为四周都是墙，bfs时，可以不做越界判断
            {
                cin >> a[i][j];
                if(a[i][j] == 'S')//记录下起点位置。
                    start.first = i, start.second = j, a[i][j] = '#';
            }
        }
        bfs(start);
    }
}
```

### 红与黑

```c++
#include<iostream>
#include<cstring>
#include<queue>
#define x first
#define y second

using namespace std;
typedef pair<int,int> PII;

const int N=30;

char g[N][N];
int n,m;
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
bool st[N][N];

int bfs(int x,int y)
{
    int cnt=1;
    queue<PII> q;
    q.push({x,y});
    while(q.size())
    {
        PII t=q.front();
        q.pop();
        int x=t.x,y=t.y;
        for(int i=0;i<4;i++)
        {
            int a=x+dx[i],b=y+dy[i];
            if(a<0 || a>=n || b<0 || b>=m) continue;
            if(st[a][b]) continue;
            if(g[a][b]!='.') continue;
            st[a][b]=true;
            q.push({a,b});
            cnt++;
        }
    }
    return cnt;
}


int main()
{
    while(cin>>m>>n,n||m)
    {
        memset(st,0,sizeof st);
        for(int i=0;i<n;i++) scanf("%s",g[i]);
        int x,y,flag=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
                if(g[i][j]=='@')
                {
                    x=i,y=j;
                    flag=1;
                }
            if(flag) break;
        }
        cout<< bfs(x,y) <<endl;
    }
    return 0;
}
```

### 等差数列

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    sort(a, a + n);

    int x = a[0], y = a[n - 1];

    int d = 0;  //0与任意数的最大公约数都是其本身
    for (int i = 0; i < n - 1; i ++ )
        d = gcd(d, a[i + 1] - a[i]);

    if (!d) printf("%d\n", n);  //公差为0的情况
    else printf("%d\n", (y - x) / d + 1);

    return 0;
}
```

### 苹果放置盘子

```c++
暴力
#include <iostream>
using namespace std;
int m, n;
int res;
void dfs(int t, int start, int state){  //state  已经完成的分身   start下一个分身的值   t剩余的能量
    if(state == n && t == 0){
        res ++;
    }
    if(state >= n)   return ;
    for(int i = start; i <= t; i ++ ){
        dfs(t-i, i, state+1);
    }
}
int main(){
    int T;
    cin >> T;
    while(T -- ){
        cin >> m >> n;
        res = 0;
        dfs(m, 0, 0);
        cout << res << endl;
    }
    return 0;
}
```

### 糖果

```c++
/*
 状态表示:
    集合: 所有的从i个物品中选, 且选出的糖数的总和%k==j的所有方案的集合
    属性: f(i,j) =最大值

 状态计算:(划分的依据是所有方案是所有方案的最后一个不同点)
    如何计算划分的集合?
        从实际含义出发(状态表示中的集合)
    不包含物品i的集合: f(i-1,j)
    包含物品i的集合: f(i-1,(j-wi)%k+wi)    --> 这里需要注意负数取模==0|负数  优化-> (j+k-wi%k)%k
    最终是: f(i,j)=max(f(i-1,j),f(i-1,(j-wi)%k+wi))
 */

#include<iostream>
#include<cstring>

using namespace std;

const int N = 1e2 + 10;

int n, k;
int f[N][N];

int max(int x, int y) {
    return x > y ? x : y;
}

int main() {
    cin >> n >> k;

    memset(f, -0x3f, sizeof f); //初始化为 -∞

    f[0][0] = 0; //只有f[0][0]是有意义的

    for (int i = 1; i <= n; i++) {
        int w;
        cin >> w;
        //余数一定是 0 - k-1 的
        for (int j = 0; j < k; j++) {
//            f[i][j] = max(f[i - 1][j], f[i - 1][(j - w) % k] + w);  后半部分 要考虑c++中的取模运算, 负数取模是0或者负数
//                                                                    可以改成
            f[i][j] = max(f[i - 1][j], f[i - 1][(j + k - w % k) % k] + w);
        }
    }
    // 答案是从n个数中选, %k 余数为0的最大值
    cout << f[n][0] << endl;
    return 0;
}
```

### 修改数组

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int n;
int p[N];

int find(int a){
    if(p[a] != a) p[a] = find(p[a]);
    return p[a];
}

int main(){
    
    cin>>n;
    for(int i = 0; i < N; i++){
        p[i] = i;
    }
    for(int i = 0; i < n; i++){
        int x; 
        scanf("%d", &x);
        x = find(x);
        printf("%d ", x);
        p[x] = x + 1;
    }
    
    return 0;
}
```

### 整数拼接

```c++
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

typedef long long LL;
const int N=100010;
int s[11][N];//表示某个数*10^i%k==j的数量
int n;//表示将要输入的n个数
LL a[N];//存放n个数
int k;//表示k倍
LL res;//表示结果

int main()
{
    //1.输入数据
    cin >> n >> k;
    for(int i = 0; i < n; i ++)
        cin >> a[i];

    //2.预处理s数组
    for(int i = 0; i < n; i ++)
    {
        LL t = a[i] % k;

        for(int j = 0; j < 11; j ++)//因为题目中给出的最大数是10^9
        {
            s[j][t] ++;
            t = t * 10 % k;
        }            
    }

    //3.循环数组计算答案
    for(int i = 0; i < n; i ++)
    {
        LL t = a[i] % k;
        int len = to_string(a[i]).size();//将这个数字转化为字符串，再判断转换后的字符串的位数就等于这个数字本身的位数
        res += s[len][(k - t) % k];

        //4.判重
        LL r = t;
        while(len--) r = r * 10 % k;  //等价于求a[i]乘以10^len的余数，同上面的预处理求法一样
        if(r == (k - t) % k) res --;
    }

    //5.输出答案
    cout << res << endl;

    return 0;
}
```

### 网络分析

```c++
#include<cstdio>
#include<cstring>

const int N = 200010, M = N << 1;

int h[N], e[M], ne[M], idx;
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int n, m;
int p[N];
int find(int x)
{
    if(p[x] != x)  p[x] = find(p[x]);
    return p[x];
}

int f[N];

void dfs(int u, int fa)
{
    f[u] += f[fa];
    for(int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        dfs(j, u);
    }
}

int main()
{
    memset(h, -1, sizeof h);

    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n * 2; i ++)  p[i] = i;

    int root = n + 1;
    while(m --)
    {
        int op, a, b;
        scanf("%d%d%d", &op, &a, &b);
        if(op == 1)
        {
            a = find(a), b = find(b);
            if(a != b)
            {
                p[a] = p[b] = root;
                add(root, a);
                add(root, b);
                root ++;
            }
        }
        else
        {
            a = find(a);
            f[a] += b;
        }
    }

    for(int i = 1; i < root; i ++)
        if(p[i] == i)  dfs(i, 0);

    for(int i = 1; i <= n; i ++)
        printf("%d ", f[i]);
    return 0;
}
```

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010;

int n, m;
int p[N], d[N];

int find(int x)
{
    if (p[x] == x || p[p[x]] == p[x]) return p[x];
    int r = find(p[x]);
    d[x] += d[p[x]];
    p[x] = r;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    while (m -- )
    {
        int t, a, b;
        scanf("%d%d%d", &t, &a, &b);
        if (t == 1)
        {
            a = find(a), b = find(b);
            if (a != b)
            {
                d[a] -= d[b];
                p[a] = b;
            }
        }
        else
        {
            a = find(a);
            d[a] += b;
        }
    }

    for (int i = 1; i <= n; i ++ )
        if (i == find(i)) printf("%d ", d[i]);
        else printf("%d ", d[i] + d[find(i)]);
    puts("");

    return 0;
}
```

### 砝码

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 110, M = 2e5 + 10;
int sum;
int n;
int w[N];
bool f[N][M];

int main() {

    cin>>n;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &w[i]);
        sum+=w[i];
    }

    f[0][0]=true;

    for (int i = 1; i <= n;i++)
        for (int j = 0; j <=sum;j++)
            f[i][j]=f[i-1][j]||f[i-1][j+w[i]]||f[i-1][abs(j-w[i])];
                //只要有一个非空,f[i][j]就非空
    int ans = 0;
    for (int i = 1; i <=sum;i++)
        if(f[n][i])ans++;//不为零说明可以选出这个质量的砝码

    cout << ans;

    return 0;
}
```

```c++
#include<stdio.h> 
int n;
int res;
int w[1000000]; 
bool st[100000];
void dfs(int k,int sum)//表示k个的砝码,重量是sum 
{
    if(k>n)//k>n 说明选完n个砝码 
    {
        if(sum>0&&!st[sum])// 判断选出来的n个砝码的重量是否没被标记过 ，如没标记则答案加1 
        {
            res++;
            st[sum]=true;//标记这个重量 
            return;
        }   
    }
    //还没选够n个砝码 
    else
    {
        dfs(k+1,sum-w[k]);//砝码放右边 
        dfs(k+1,sum);//跳过，不选用当前的砝码 
        dfs(k+1,sum+w[k]);//砝码放左边 
    }
}
int main()
{
    scanf("%d",&n); 
    for(int i=1;i<=n;i++)scanf("%d",&w[i]); 

    dfs(0,0);
    printf("%d",res); 
}
```

### 双向排序 暴力

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N=100010;
int a[N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++) a[i]=i+1;

    while(m)
    {
        int t;
        cin>>t;
        if(t)
        {
            int e;
            cin>>e;
            sort(a+(e-1),a+n);
        }else
        {
            int s;
            cin>>s;
            sort(a,a+s,greater<int>());
        }

        m--;
    }

    for(int i=0;i<n;i++) cout<<a[i]<<" ";
    return 0;
}
```

### 负载均衡

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;
typedef pair<int, int> PII;

const int N = 200010;

int n,m;
int s[N];//每台计算机算力
priority_queue<PII,vector<PII>,greater<PII> >q[N];//每台计算机任务
//PII <结束时刻,算力>
//!要小根堆
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++ i)scanf("%d",&s[i]);//!下标从1开始
    while (m -- ){
        int a,b,c,d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        while(q[b].size()&&q[b].top().x<=a){//当堆尾的结束时刻小于当前分配时刻
            s[b] += q[b].top().y;//!恢复算力 +
            q[b].pop();//弹出该任务

        }
        if(s[b]<d)puts("-1");//当前算力无法分配
        else{
            q[b].push({a+c,d});//加入任务
            s[b] -= d;//更新算力
            printf("%d\n",s[b]);//输出算力

        }
    }
    return 0;

}
```

### 国际象棋

```c++
#include<iostream>
using namespace std;
const int N=1<<6;
const int M=110;
const int T=30;
const int mod=1e9+7;
typedef long long ll;
ll f[M][N][N][T];//f[i][a][b][t] i 代表前i列 a代表前前列，b代表前面一列的状态集合 t代表已经用过多少个棋子
int lowit(int x){//计算当前列增加了多少个棋子
    int res=0;
    for(;x;x-=(x&-x))res++;
    return res;
}
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    int maxn=1<<n;
    f[0][0][0][0]=1;//初始化
    for(int i=1;i<=m;i++)
        for(int a=0;a<maxn;a++)
            for(int b=0;b<maxn;b++)
                if((a>>2)&b||a&(b>>2))continue;//判断前前列和前列有没有发生冲突剪枝
                else
                    for(int c=0;c<maxn;c++){
                        if((c>>2)&b||c&(b>>2))continue;//判断前列和当前列有没有发生冲突
                        if((c>>1)&a||c&(a>>1))continue;//判断前前列和当前列有没有发生冲突
                        int t=lowit(c);
                      // 那么还剩 j - t 个棋子摆放在 前i - 1层，将所有合法状态 累加
                        for(int tt=t;tt<=k;tt++)
                            f[i][b][c][tt]=(f[i][b][c][tt]+f[i-1][a][b][tt-t])%mod;
                    }
    int res=0;
    for(int i=0;i<maxn;i++)//对前前列和前列不同的状态最终有多少个可以摆放的方案数
        for(int j=0;j<maxn;j++)
            res=(res+f[m][i][j][k])%mod;
    cout<<res;
}
```

### 统计子矩阵

```c++
#include<iostream>
using namespace std;

typedef long long ll;
const int N = 5e2+3;
int n, m, k;
int a[N][N];


int main(){
    ios::sync_with_stdio(false);
    cin >> n >> m >> k;
    for(int i=1; i<=n; i++){
        for(int j=1; j<=m; j++){
            cin >> a[i][j];
            a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
        }
    }

    ll ans = 0;
    for(int i=1; i<=m; i++){
        for(int j=i; j<=m; j++){
            for(int s = 1, t = 1; t <= n; t ++ ){
                while(s <= t && a[t][j] - a[s - 1][j] - a[t][i - 1] + a[s - 1][i - 1] > k) s ++ ;
                if(s <= t) ans += t - s + 1;
            }
        }
    }

    cout << ans << '\n';
}
```

### 积木

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e7 + 10, mod = 1000000007;

int g[4][4] = {
    {1, 1, 1, 1},
    {0, 0, 1, 1},
    {0, 1, 0, 1},
    {1, 0, 0, 0},
};

int f[N][4];

int main()
{
    int n;
    cin >> n;

    f[1][0] = 1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < 4; j ++ )
            for (int k = 0; k < 4; k ++ )
            {
                f[i + 1][k] = (f[i + 1][k] + f[i][j] * g[j][k]) % mod;
            }


    cout << f[n + 1][0];

    return 0;
}
```

```c++
#include <iostream>

using namespace std;

const int mod = 1e9+7;
long long dp[2][3]; // dp[i][j]表示前i列填满并且填了第i+1列j个位置的方案

int main() {
    int n;
    cin >> n;
    dp[1][0] = 1; // 一个长条竖着放
    dp[1][1] = 2; // 一个L型竖着放（可以上下翻转所以是两种）  
    dp[1][2] = 1; // 两个长条横着放
    for(int i = 2; i <= n; i++) {
        // 这一列长条竖着放 + 前一列占满
        dp[i&1][0] = (dp[i-1&1][0] + dp[i-1&1][2]) % mod; 
        // 一个L型竖着放（上下翻转*2） + 这一列被占一个再横着放一个长条
        dp[i&1][1] = (dp[i-1&1][0] * 2 + dp[i-1&1][1]) % mod; 
        // 这一列两个长条横着放 + 一个L型摆成7字形
        dp[i&1][2] = (dp[i-1&1][0] + dp[i-1&1][1]) % mod;
    }
    cout << dp[n&1][0];
    return 0;
}
```

```c++
#include <iostream>

using namespace std;
const int N = 1e7 + 10;
const int mod = 1e9 + 7;
long long dp[N][3]; // dp[i][j]表示前i列填满并且填了第i+1列j个位置的方案

int main() {
    int n;
    cin>>n;
    
    dp[1][0] = 1; dp[1][1] = 2; dp[1][2] = 1;
    for(int i = 2; i <= n; i++){
        
        dp[i][0] = (dp[i - 1][0] + dp[i - 1][2]) % mod;
        dp[i][1] = (dp[i - 1][1] + dp[i - 1][0] * 2) % mod;
        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % mod;
    }
    
    cout<<dp[n][0];

    return 0;
}
```

### 李白打酒

![image-20230323210915009](/Users/xuruihang/Library/Application Support/typora-user-images/image-20230323210915009.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 110, M = 1000000007;
int n, m, f[N][N][N][2];

int main()
{
    scanf("%d%d", &m, &n);

    for(int i = 0; i <= n; i ++ )
    {
        for(int j = 0; j <= m; j ++ )
        {
            for(int k = 0; k < 100; k ++ )
            {
                for(int c = 0; c < 2; c ++ )
                {
                    if(i == 0 && j == 0 && k == 2 && c == 1)
                    f[i][j][k][c] = 1;

                    if(i == 0 && j == 0)
                    continue;

                    if(j > 0 && c == 1 && k % 2 == 0)
                    {
                        f[i][j][k][c] = (f[i][j - 1][k / 2][0] + f[i][j - 1][k / 2][1]) % M;
                    }

                    if(i > 0 && c == 0 && k >= 0)
                    {
                        f[i][j][k][c] = (f[i - 1][j][k + 1][0] + f[i - 1][j][k + 1][1]) % M;
                    }
                }   
            }
        } 
    }

    printf("%d", f[n][m][0][0]);
    return 0;
} 
```

```c++
/*初始化的时候把 f[0][0][2] 初始化为1，其他 f[0][0][k] 都为0，
表示一开始只有李白手里拿2斗酒这一种情况。
最后打印答案的时候不是打印 f[n][m][0] ,因为这么打印是无法区分最后是到花还是到店，
我们可以往前推一步，如果最后到花，那么喝完的上一步应该是f[n - 1][m][1],
所以最后答案是f[n - 1][m][1]
**/
#include<bits/stdc++.h> 
using namespace std;


const int N = 110, M = 1000000007;
int n, m, f[N][N][N];

int main()
{
    scanf("%d%d", &m, &n);

    for(int i = 0; i <= n; i ++ )
    {
        for(int j = 0; j <= m; j ++ )
        {
            for(int k = 0; k < N; k ++ )
            {
                if(i == 0 && j == 0 && k == 2)
                f[i][j][k] = 1;

                if(i == 0 && j == 0)
                continue;

                if(i > 0)
                f[i][j][k] = (f[i][j][k] + f[i - 1][j][k + 1]) % M;

                if(j > 0 && k % 2 == 0)
                f[i][j][k] = (f[i][j][k] + f[i][j - 1][k / 2]) % M;
            }
        } 
    }

    printf("%d", f[n - 1][m][1]);
    return 0;
} 
```

